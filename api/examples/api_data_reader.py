#!/usr/bin/env python3
"""
Read/decrypt Satellite API data received via Blockstream Satellite
"""

import os, sys, argparse, textwrap, struct, zlib, time, logging, socket, errno
import fcntl, requests
from datetime import datetime
from textwrap import fill
import gnupg, getpass


# Constants/definitions
BLOCKSAT_PKT_HEADER_FORMAT = '!cxHI'
# Header format:
# octet 0    : Type bit on LSB, MF bit on MSB
# octet 1    : Reserved
# octets 2-3 : Fragment number
# octets 4-7 : API message's sequence number
BLOCKSAT_PKT_HEADER_LEN    = 8
TYPE_API_DATA              = b'\x01'
USER_HEADER_FORMAT         = '255sxI' # Message header from `api_data_sender.py`
USER_HEADER_LEN            = 255 + 1 + 4
MAX_READ                   = 2**16
DOWNLOAD_DIR               = "downloads"
SIOCGIFINDEX               = 0x8933 # Ioctl request for interface index
IP_MULTICAST_ALL           = 49


def save_file(data, filename=None):
    """Save data into a file

    Save given sequence of octets into a file with given name. If the name is
    not specified, use a timestamp as the file name.

    Args:
        data     : Data to save (bytes)
        filename : Name of the file to save (optional)

    """
    assert(isinstance(data, bytes))

    # Save file into a specific directory
    if not os.path.exists(DOWNLOAD_DIR):
        os.makedirs(DOWNLOAD_DIR)

    if (filename is None):
        filename = time.strftime("%Y%m%d%H%M%S")

    # Write file with user data
    f = open(os.path.join(DOWNLOAD_DIR, filename), 'wb')
    f.write(data)
    f.close()

    logging.info("Saved in %s." %(os.path.join(DOWNLOAD_DIR, filename)))


def parse_user_data(data):
    """Parses the user-specific protocol data structure

    Parses the user-specific data structure generated by the
    "api_data_sender.py" example application. Unpacks the CRC32 checksum and the
    file name of the user-specific header. Then, validates the data integrity
    using the checksum and saves the file with the given file name.

    Args:
        data : Bytes object with the raw received data buffer

    Returns:
        Boolean indicating whether the parsing was successful

    """

    if (len(data) < USER_HEADER_LEN):
        logging.warning("Message length is less than 260 bytes")

        info_str = ("Have you used the api_data_sender app with --send-raw "
                    "option or another transmission app? In this case, "
                    "consider running the api_data_reader app with "
                    "--save-raw option.")
        logging.info(fill(info_str, width=80))
        logging.info("We will fall back and save the raw data...")
        return False

    # Parse the user-specific header
    user_header = struct.unpack(USER_HEADER_FORMAT, data[:USER_HEADER_LEN])
    filename    = user_header[0].rstrip(b'\0').decode()
    checksum    = user_header[1]

    # Validate data integrity
    user_data  = data[USER_HEADER_LEN:]
    data_crc32 = zlib.crc32(user_data)

    if (data_crc32 != checksum):
        logging.error("Checksum (%d) does not match the header value (%d)" %(
            data_crc32, checksum
        ))

        info_str = ("This could be because some data was lost over the "
                    "satellite link or because the message was sent without a "
                    "user-specific header containing a checksum. The latter "
                    "would be the case if using the api_data_sender app with "
                    "--send-raw option or if using another Blocksat message "
                    "transmission app. In this case, consider running the "
                    "api_data_reader app with --save-raw command-line option. "
                    "We will fall back and save the raw data...")
        logging.info(fill(info_str, width=80))

        return False
    else:
        logging.info("File: %s\tChecksum: %d\tSize: %d bytes" %(
            filename, checksum, len(user_data)))

    save_file(user_data, filename)

    return True


def unpack(udp_payload):
    """Unpack Blocksat Packet from UDP payload

    Args:
        udp_payload : UDP payload received via socket (bytes)

    Returns:
        Tuple with the Blocksat Packet's payload (bytes) and sequence number

    """

    octet_0, i_frag, seq_num = struct.unpack(BLOCKSAT_PKT_HEADER_FORMAT,
                                             udp_payload[:BLOCKSAT_PKT_HEADER_LEN])
    # Sanity checks
    assert(ord(octet_0) & 1), "Not an API packet"
    more_fragments = ord(octet_0) & ord(b'\x80')
    payload        = udp_payload[BLOCKSAT_PKT_HEADER_LEN:]
    return (payload, seq_num, i_frag, more_fragments)


def check_gaps(frag_map):
    """Check if there were any fragment number gaps"""
    frag_idxs = sorted(frag_map.keys())
    for i,x in enumerate(frag_idxs):
            if (i == 0 and x != 0):
                if (x > 1):
                    logging.warning("First %d fragments were lost" %(x))
                else:
                    logging.warning("First fragment was lost")
            elif (i > 0 and x - frag_idxs[i-1] != 1):
                logging.warning("Gap between fragment %d and fragment %d",
                                frag_idxs[i-1], x)


def concat_chunks(frag_map):
    """Concatenate message chunks"""
    msg = bytes()
    for i_frag in sorted(frag_map):
        assert(isinstance(frag_map[i_frag], bytes))
        msg += frag_map[i_frag]

    return msg


def open_udp_sock(sock_addr, ifname):
    """Instantiate UDP socket

    Args:
        sock_addr : Socket address string
        ifname    : Network interface name

    Returns:
        Socket object

    """
    udp_sock_ip, udp_sock_port_str = sock_addr.split(":")
    udp_sock_port                  = int(udp_sock_port_str)
    assert(udp_sock_ip is not None), "UDP source IP is not defined"
    assert(udp_sock_port is not None), "UDP port is not defined"

    logging.debug("Connect with UDP socket %s:%s" %(udp_sock_ip,
                                                    udp_sock_port))
    try:
        # Open and bind socket to Blocksat API port
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

        # Allow reuse and bind
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', udp_sock_port))

        # Get the network interface index
        if (ifname is not None):
            ifreq   = struct.pack('16si', ifname.encode(), 0)
            res     = fcntl.ioctl(sock.fileno(), SIOCGIFINDEX, ifreq)
            ifindex = int(struct.unpack('16si', res)[1])
            logging.debug("Join multicast group %s on network interface %d" %(
                udp_sock_ip, ifindex
            ))
        else:
            logging.debug("Join group %s with the default network interface" %(
                udp_sock_ip
            ))
            ifindex = 0

        # Join multicast group on the chosen interface
        ip_mreqn = struct.pack('4s4si',
                               socket.inet_aton(udp_sock_ip),
                               socket.inet_aton('0.0.0.0'),
                               ifindex)
        sock.setsockopt(socket.IPPROTO_IP,
                        socket.IP_ADD_MEMBERSHIP,
                        ip_mreqn)

        # Make sure that this socket receives messages solely from the above
        # group that was explicitly joined above
        sock.setsockopt(socket.IPPROTO_IP, IP_MULTICAST_ALL, 0)
    except socket.error as e:
        if (e.errno == errno.EADDRNOTAVAIL):
            logging.error("Error on connection with UDP socket %s:%s" %(
                udp_sock_ip, udp_sock_port))
            logging.info("Use argument `--sock-addr` to define the socket address.")
        raise

    return sock


def confirm_rx(server, tx_seq_num, region, tls_cert=None, tls_key=None):
    """Confirm reception of a Blocksat Packet

    Args:
        server     : API server address
        tx_seq_num : API message tx sequence number
        region     : Coverage region
        tls_key    : API client key
        tls_cert   : API client certificate

    """
    if (region is None) or (tls_cert is None) or (tls_key is None):
        return

    logging.info("Confirm reception of API message #%d on region %d" %(
        tx_seq_num, region))
    r = requests.post(server + '/order/rx/' + str(tx_seq_num),
                      data = {
                          'region' : region
                      },
                      cert = (tls_cert, tls_key))

    if not r.ok:
        logging.error("Failed to confirm Rx of #%d [status code %d]" %(
            tx_seq_num, r.status_code
        ))
    else:
        logging.info("Server response: " + r.json()['message'])



def main():
    parser = argparse.ArgumentParser(
        description=textwrap.dedent('''\
        Example Blockstream Satellite API data reader application

        Receives Blocksat API data via a UDP socket that listens to the API
        multicast address. By default, assumes that incoming messages are
        generated by the example "API data sender" application, which frames and
        encrypts the message prior to transmission. Thus, this application first
        attempts to decrypt the data using a local GnuPG key and, on successful
        decryption, validates the integrity of the data. In the end, saves the
        file in the "downloads/" directory.

        '''),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument('--sock-addr',
                        default="239.0.0.2:4433",
                        help='Multicast UDP address (ip:port) used to ' +
                        'listen for API data')

    intf_arg = parser.add_mutually_exclusive_group(required=True)

    intf_arg.add_argument('-i', '--interface', default=None,
                          help="Network interface that receives API data")

    intf_arg.add_argument('-d', '--demo',
                          action="store_true",
                          default=False,
                          help="Use the same interface as demo-rx, i.e. the " +
                          "loopback interface")

    parser.add_argument('-g', '--gnupghome', default=".gnupg",
                        help='GnuPG home directory')

    encr_arg = parser.add_mutually_exclusive_group()

    encr_arg.add_argument('--save-raw', default=False,
                          action="store_true",
                          help='Save the raw decrypted data in the ' +
                          '\"downloads/\" folder while ignoring the ' +
                          'existence of a user-specific data structure. ')

    encr_arg.add_argument('--plaintext', default=False,
                          action="store_true",
                          help='Do not try to decrypt the data. Instead, ' +
                          'assume that all API data transmissions are ' +
                          'plaintext and save them as individual files ' +
                          'named by timestamps in the  \"downloads/\" ' +
                          'folder. NOTE: this saves all transmissions in the ' +
                          ' \"downloads/\" folder')

    parser.add_argument('--no-password', default=False,
                        action="store_true",
                        help='Set to access GPG keyring without a password ')

    parser.add_argument('-s', '--server',
                        default='https://api.blockstream.space',
                        help='Satellite API server address')

    parser.add_argument('-r', '--region',
                        choices=range(0, 6),
                        type=int,
                        help='Coverage region for Rx confirmations')

    parser.add_argument('--tls-cert',
                        default=None,
                        help='Certificate for client-side authentication')

    parser.add_argument('--tls-key',
                        default=None,
                        help='Private key for client-side authentication')

    parser.add_argument('--debug', action='store_true',
                        help='Debug mode')
    args      = parser.parse_args()
    sock_addr = args.sock_addr
    interface = "lo" if args.demo else args.interface
    gnupghome = args.gnupghome
    save_raw  = args.save_raw
    plaintext = args.plaintext

    # Switch debug level
    if (args.debug):
        logging.basicConfig(
            format='%(asctime)s %(levelname)-8s %(message)s',
            datefmt='%b %d %Y %H:%M:%S',
            level=logging.DEBUG)
        logging.debug('[Debug Mode]')
    else:
        logging.basicConfig(
            format='%(asctime)s %(levelname)-8s %(message)s',
            datefmt='%b %d %Y %H:%M:%S',
            level=logging.INFO)

    # GPG object
    if (not plaintext):
        gpg = gnupg.GPG(gnupghome = gnupghome)

        # Is there a password for GPG keyring?
        if (args.no_password):
            gpg_password = None
        else:
            gpg_password = getpass.getpass(prompt='GPG keyring password for '
                                           'decryption: ')

    # Open interface to API data
    sock = open_udp_sock(sock_addr, interface)

    logging.info("Waiting for data...")
    frag_map = {}
    while True:
        udp_payload, addr = sock.recvfrom(MAX_READ)
        data_chunk, seq_num, frag_idx, more_frags = unpack(udp_payload)

        # Append the incoming Blocksat packet to a dictionary that maps packets
        # pertaining to the same API message.
        if (seq_num not in frag_map):
            frag_map[seq_num] = {}
        frag_map[seq_num][frag_idx] = data_chunk

        # Once the last fragment comes, concatenate all data chunks of the
        # message (each on the payload of a Blocksat packet) and process it.
        if (more_frags):
            continue

        logging.info("-- API message %d" %(seq_num))
        logging.debug("Message source: %s:%s" %(addr[0], addr[1]))
        logging.info("Fragments: %d" %(len(frag_map[seq_num].keys())))
        check_gaps(frag_map[seq_num])
        data = concat_chunks(frag_map[seq_num])
        # We are done with the fragments, so remove them from the map
        del frag_map[seq_num]
        # Send confirmation of reception to API server
        confirm_rx(args.server, seq_num, args.region, args.tls_cert,
                   args.tls_key)

        if (len(data) == 0):
            logging.warning("Empty message")
            continue

        # In plaintext mode, every API transmission is assumed to be
        # plaintext and output as a file to the downloads folder with a
        # timestamp as name.
        if (plaintext):
            logging.info("Size: %7d bytes\tSaving as plaintext" %(len(data)))
            save_file(data)
            logging.debug("Message: %s" %data)
            continue

        # Try to decrypt the data when not in plaintext mode
        decrypted_data = gpg.decrypt(data, passphrase = gpg_password)

        if (not decrypted_data.ok):
            logging.info(
                "Size: %7d bytes\t Decryption: FAILED\t" %(len(data)) +
                "Not encrypted for us (%s)" %(decrypted_data.status)
            )
            continue

        # Is the message digitally signed?
        if (decrypted_data.fingerprint is not None):
            signed_by = decrypted_data.fingerprint

            # Was the signature verified?
            if decrypted_data.trust_level is not None:
                sign_str = "Signed by %s (verified w/ trust level: %s)" %(
                    signed_by, decrypted_data.trust_text
                )
            else:
                sign_str = "Signed by %s (unverified)" %(signed_by)

            unsign_str = ""
        else:
            unsign_str = "Not signed"
            sign_str = ""

        logging.info("Encrypted size: %7d bytes\t Decryption: OK    \t%s" %(
            len(data), unsign_str))
        if (len(sign_str) > 0):
            logging.info(sign_str)
        logging.info("Decrypted size: %7d bytes" %(len(str(decrypted_data))))

        # Parse the user-specific data structure. If ignoring the
        # existence of an application-specific data structure, save the
        # raw decrypted data directly to a file.
        if (save_raw):
            save_file(decrypted_data.data)
        else:
            parse_ok = parse_user_data(decrypted_data.data)

            # Save raw data in case parsing fails
            if (not parse_ok):
                save_file(decrypted_data.data)



if __name__ == '__main__':
    main()
